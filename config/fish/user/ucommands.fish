function update_bashrc -d "Convert the fish/user/ files to a single ~/.bashrc file."
	set BASHPROMPT_FILE "$HOME/.config/fish/assets/prompt.bash"  #- Custom prompt to append to the final .bashrc file
	set GVARS_FILE "$HOME/.config/fish/user/gvariables.fish"     #- Global variables list file
	set ALIASRC_FILE "$HOME/.config/fish/user/aliasrc.fish"      #- File with the alias/abbr list written in a special syntax
	set BRC "$HOME/.bashrc"                                      #- I called this var that short to longer lines

	#- Displays an warnning message and then ask the user if it's ok to continue.
	printf "\n%s[WARNING]%s: This command will overwrite the %s~/.bashrc%s file!\n" \
		(set_color yellow) (set_color normal) (set_color -i cyan) (set_color normal)
	read -n1 -p 'printf "%s<read>%s Continue? %s[Y/n]%s " \\
	               (set_color black) (set_color normal) (set_color -i purple) (set_color normal)' answer
	echo

	string match -vr "$answer" '[Yy]' &>/dev/null &&
		return

	#- Generate a descritive message before parsing the Fish aliases & variables.
	echo "## AUTOGENERATED BASHRC CONFIG:" > "$BRC"
	echo "##  This ~/.bashrc file was automatically generated by a Fish (yeah the" >> "$BRC"
	echo "##  Fish shell) function, it has some of the same aliases and variables" >> "$BRC"
	echo "##  that this particular Fish config has!" >> "$BRC"
	echo "##" >> "$BRC"
	echo "##  More information at: http://github.com/kevinmarquesp" >> "$BRC"

	#- Actually parse the Fish config to Bash script, it's a little complicated, I know...
	sed '/.*#bign! *$/d;s/^ *#binc: *//;s/^#.*//;/^ *$/d;s/  */ /g;s/^set [^ ]* \([^ ]*\) /export \1=/' "$GVARS_FILE" >> "$BRC"  #- Minify & parse the 'set -gx' syntax to 'export VARNAME='.
	awk '/\\\\$/ {printf("%s",substr($0,1,length($0)-1))} !/\\\\$/ {print}' "$ALIASRC_FILE" |                                    #- Concatenate the lines ending with \ to the next one.
		sed 's/  */ /g;/^ *$/d;/#bign!/d;s/#binc: //g;/^#.*/d' |                                                                 #- Include and exclude the commented Bash lines.
		sed 's/^if\(.*\)$/if\1; then/;s/end/fi/g;s/(\(.*\))/$(\1)/g;s/abbr/alias/;s/\(alias [^ =]*\) /\1=/' >> "$BRC"            #- Parse some of the Fish syntax to Bash.
	sed 's/^#.*//;/^ *$/d' "$BASHPROMPT_FILE" >> "$BRC"                                                                          #- Minify, just that...

	printf "%s[SUCCESS]%s: %s~/.bashrc%s file updated!\n\n" \
		(set_color green) (set_color normal) (set_color -i cyan) (set_color normal)
end

function slug -d "Given a string, it will return a kebab slug."
	if [ -z "$argv" ]
		while read pipe
			slug "$pipe"
		end

		return
	end

	echo "$argv" |
		iconv -t "ASCII//TRANSLIT" |
		tr "[:punct:]" " " |
		sed 's/\(.*\)/\L\1/;s/ *$//;s/  */-/g'
end

function clone -d "Clone a git repository but format the directory name to use my convention."
	argparse --name="clone" "f/fork" "b/branch=" -- $argv ||
		return

	# Try extract the repo and owner strings from a HTTP or SSH URL.
	echo "$argv" |
		grep "^https\?://" |
		sed 's/https\?:\/\/.*\/\(.*\)\/\(.*\)/{"owner": "\1", "repo": "\2"}/g' |
		read repo_data

	if [ -z "$repo_data" ]
		echo "$argv" |
			grep "^git@.*\.git\$" |
			sed 's/^git@.*:\(.*\)\/\(.*\)\.git$/{"owner": "\1", "repo": "\2"}/g' |
			read repo_data
	end

	if [ -z "$repo_data" ] || not echo "$repo_data" | jq "." &>/dev/null
		echo "Could not find the repo and owner name in the given string."
		return 1
	end

	# Build the direcotry name based with the given information.
	set owner (echo "$repo_data" | jq -r ".owner" | slug)
	set repo (echo "$repo_data" | jq -r ".repo" | slug)

	set name "$owner.$repo"

	if [ -n "$_flag_fork" ]
		set name "FORKED.$owner.$repo"
	end

	# Finally, clone the repository to the target directory name.

	if [ -z "$_flag_branch" ]
		git clone "$argv" "$name"
	else
		git clone "$argv" -b "$_flag_branch" "$name"
	end
end
